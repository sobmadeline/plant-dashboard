<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
  <title>Bookings Dashboard - BRAC Tools</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            pindan: "#C54B00",
            darkturq: "#004153",
            bg: "#07141a",
            card: "#0b2028",
            line: "#14313b",
            muted: "#cbd5e1",
            good: "#15803d",
            warn: "#ca8a04",
            bad: "#b91c1c",
            plan: "#2563eb",
            teal: "#0f766e"
          }
        }
      }
    }
  </script>
  
  <style>
  
  /* Venue grid
     - Desktop (>=901px): fit-to-screen scaling, no page scroll, no internal scrollbars.
     - Mobile: normal flow + page scroll (readability wins). */
  #venueStage{
    height: calc(100vh - 86px);
    overflow: hidden;
  }

  #venueWrap{
    --dashScale: 1;
    --gap: 14px;
    --pad: 14px;

    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(290px, 1fr));
    gap: var(--gap);
    padding: var(--pad);

    transform: scale(var(--dashScale));
    transform-origin: top left;
    width: calc(100% / var(--dashScale));
  }

  .bookingList{
    overflow: hidden; /* no scrollbars inside cards */
    min-height: 0;
  }

  /* Mobile/tablet: allow the page to scroll normally (no scaling) */
  @media (max-width: 900px){
    #venueStage{ height: auto; overflow: visible; }
    #venueWrap{ transform: none; width: 100%; }
  }


  /* Tighter booking rows to help fit more on-screen */
  .bookingRow{
    padding: 10px 12px !important;
  }
  .bookingRow .title{
    font-size: clamp(12px, 1.05vw, 14px);
    line-height: 1.15;
  }
  .bookingRow .meta{
    font-size: clamp(11px, 0.95vw, 12px);
    line-height: 1.2;
  }

  /* Responsive columns */
  @media (max-width: 1400px){ #venueWrap{ grid-template-columns: repeat(3, minmax(0,1fr)); } }
  @media (max-width: 1100px){ #venueWrap{ grid-template-columns: repeat(2, minmax(0,1fr)); height: calc(100vh - 120px);} }
  @media (max-width: 800px){  #venueWrap{ grid-template-columns: repeat(1, minmax(0,1fr)); height: calc(100vh - 140px);} }
</style>

</head>

<body class="m-0 font-sans bg-bg text-slate-50 text-[15px] min-h-screen overflow-hidden">
  <!-- Header -->
  <header class="bg-darkturq px-2 py-3.5 md:flex items-center justify-between gap-4">
  <!-- Left: logo + titles -->
    <div class="flex items-center gap-3 min-w-0">
      <a href="index.html" class="max-h-10 max-w-[211px] rounded-xl text-white flex items-center justify-center font-black tracking-wide">
        <img src="./images/WhiteWebsiteLogo.png" alt="BRAC Logo" class="object-contain" />
      </a>
      <div class="min-w-0">
        <div class="text-[18px] font-black leading-tight truncate">Bookings Dashboard</div>
        <div class="text-[13px] opacity-85 mt-0.5 truncate">Broome Recreation & Aquatic Centre</div>
        <div class="text-[12px] font-extrabold text-muted mt-0.5 truncate" id="sourceInfo">—</div>
      </div>
    </div>

    <!-- Right: controls -->
    <div class="flex items-center gap-2 shrink-0 md:mt-0 mt-4">
      <input id="datePick" type="date"
        class="rounded-xl border border-line bg-[#06181f] px-3 py-2 text-sm font-extrabold"
        onchange="render()" />

      <button class="rounded-2xl px-3 py-2 font-black text-white bg-plan"
        type="button" onclick="loadAll(true)">Refresh</button>

      <a href="./bookings-add.html"
        class="rounded-2xl px-3 py-2 font-black text-white bg-pindan inline-block">
        + Add booking
      </a>
    </div>
  </header>


  <main id="venueStage"><div id="venueWrap"></div></main>

  <!-- Toast -->
  <div id="toast" style="display:none"
    class="fixed bottom-3 left-1/2 -translate-x-1/2 bg-[#06181f] border border-line rounded-2xl px-4 py-2 text-sm font-black shadow">
  </div>

<script>
  // ====== CONFIG ======
  const WRITE_URL = "https://script.google.com/macros/s/AKfycbzygxLa5-VSIkWuFe1jWt930bK0kMhrn0QKR8aAKFuF5wSaRagoATKWMfESgQu6OkizHQ/exec";

  const VENUES = [
    "Swimming Pool",
    "Stadium",
    "Multipurpose Room",
    "Tennis Courts",
    "Outdoor Courts",
    "Squash Courts",
    "Medland Pavilion",
    "Nipper Roe Oval",
    "Father Mac Oval",
    "Haynes Oval",
    "Male Oval",
    "Beach Wheelchair"
  ];

  // ====== STATE ======
  let manualBookings = [];
  let pmBookings = [];
  let lastPerfectMindFile = "";

  // ====== UI HELPERS ======
  function toast(msg, ms=1800){
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.style.display = "block";
    setTimeout(()=> t.style.display="none", ms);
  }

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
    }[c]));
  }

  function toMin(t){
    // HH:MM -> minutes
    const m = /^(\d{1,2}):(\d{2})$/.exec(String(t||"").trim());
    if (!m) return 999999;
    return (parseInt(m[1],10)*60) + parseInt(m[2],10);
  }

  
  function normalizeDate(s){
    // Normalise to ISO YYYY-MM-DD so we can compare dates reliably
    const str = String(s ?? "").trim();
    if (!str) return "";
    if (/^\d{4}-\d{2}-\d{2}$/.test(str)) return str;

    // dd/mm/yyyy or d/m/yyyy (AU style)
    let m = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(str);
    if (m){
      const dd = m[1].padStart(2,"0");
      const mm = m[2].padStart(2,"0");
      const yyyy = m[3];
      return `${yyyy}-${mm}-${dd}`;
    }

    // dd-mm-yyyy
    m = /^(\d{1,2})-(\d{1,2})-(\d{4})$/.exec(str);
    if (m){
      const dd = m[1].padStart(2,"0");
      const mm = m[2].padStart(2,"0");
      const yyyy = m[3];
      return `${yyyy}-${mm}-${dd}`;
    }

    return str; // fallback (won't match unless both sides identical)
  }

function getSelectedDate(){
    const el = document.getElementById("datePick");
    return el.value;
  }

  // ====== NETWORK ======
  async function getJSON(url){
    const res = await fetch(url, { cache:"no-store" });
    return await res.json();
  }

  async function loadManual(){
    const data = await getJSON(`${WRITE_URL}?action=getBookings`);
    if (!data.ok) throw new Error(data.error || "Manual bookings failed");
    manualBookings = data.items || [];
  }

  async function loadPerfectMind(){
    const data = await getJSON(`${WRITE_URL}?action=getPerfectMind`);
    if (!data.ok) throw new Error(data.error || "PerfectMind failed");
    pmBookings = data.items || [];
    lastPerfectMindFile = data.fileName ? `${data.fileName}` : "";
    return data;
  }

  async function deleteManual(rowNumber){
    if (!confirm(`Delete manual booking row ${rowNumber}?`)) return;

    const body = new URLSearchParams({ action:"deleteBooking", rowNumber:String(rowNumber) });
    const res = await fetch(WRITE_URL, { method:"POST", body });
    const text = await res.text();
    if (!String(text).startsWith("OK")) {
      console.error(text);
      return toast(text || "Delete failed", 4500);
    }
    toast("Deleted ✅", 1500);
    await loadAll(false);
  }

  // ====== HELPER FUNCTIONS FOR DATA CONDENSATION ======
  function normKey(s){
    return String(s || "").trim().toLowerCase();
  }

  function uniq(arr){
    return Array.from(new Set((arr || []).map(x => String(x||"").trim()).filter(Boolean)));
  }

   // Aqua Ducks and LTS Condenser
function condenseSwimmingPoolDashboardOnly(items){
  const out = [];
  const pool = [];
  const rest = [];

  const normTime = (t) => {
    // turn "09:15", "09:15:00", "09:15 " into "09:15"
    const s = String(t || "").trim();
    const m = /^(\d{1,2}):(\d{2})/.exec(s);
    if (!m) return s;
    return `${String(m[1]).padStart(2,"0")}:${m[2]}`;
  };

  const clean = (s) => String(s || "").trim();

  (items || []).forEach(b => {
    if (clean(b.venue) === "Swimming Pool") pool.push(b);
    else rest.push(b);
  });

  const groups = new Map();

  function addToGroup(key, b, groupType, label){
    if (!groups.has(key)){
      groups.set(key, {
        ...b,
        _groupType: groupType,   // "aquduck" | "lts"
        _labels: new Set(),
        _areas: new Set(),
        _notes: new Set(),
      });
    }
    const g = groups.get(key);

    if (label) g._labels.add(label);

    const area = clean(b.area);
    if (area) g._areas.add(area);

    const notes = clean(b.notes);
    if (notes) g._notes.add(notes);
  }

  for (const b of pool){
    const name = clean(b.name).toLowerCase();

    const start = normTime(b.start);
    const end   = normTime(b.end);
    const date  = clean(b.date);

    // Match: Aqua Duck (6) / Aqua Duck 6 / Aqua Duck - 6
    let m = /^aqua\s*duck\b[\s\-:]*\(?\s*([0-9]+)\s*\)?/i.exec(clean(b.name));
    if (m){
      const label = m[1];
      const key = `pool|${date}|aquduck`;
      addToGroup(key, {...b, start, end}, "aquduck", label);
      continue;
    }

    // Match: Stage 3A / Stage 7/8 / Stage (2) etc
    m = /^stage\b[\s\-:]*\(?\s*([0-9a-z\/]+)\s*\)?/i.exec(clean(b.name));
    if (m){
      const label = m[1].toUpperCase();
      const key = `pool|${date}|lts`;
      addToGroup(key, {...b, start, end}, "lts", label);
      continue;
    }

    // Anything else stays the same
    out.push({...b, start, end});
  }

  // turn groups into cards
  for (const g of groups.values()){
    const labels = Array.from(g._labels).filter(Boolean);

    // Sort labels smart-ish: numeric first then alpha (good enough for 1,2,3A,3B,7/8)
    labels.sort((a,b) => a.localeCompare(b, undefined, { numeric:true }));

    if (g._groupType === "aquduck"){
      g.name = labels.length ? `Aqua Duck (${labels.join(", ")})` : "Aqua Duck";
    } else if (g._groupType === "lts"){
      g.name = labels.length ? `Learn to Swim (Stage ${labels.join(", ")})` : "Learn to Swim";
    }

    const areas = Array.from(g._areas);
    areas.sort((a,b) => a.localeCompare(b));
    g.area = areas.join(" • ");

    const notes = Array.from(g._notes);
    notes.sort((a,b) => a.localeCompare(b));
    g.notes = notes.join(" • ");

    out.push(g);
  }

  return out.concat(rest);
}
  
  // ====== MERGE + RENDER ======
  function mergedForDate(dateStr){
    const all = []
      .concat((manualBookings||[]).map(b => ({...b, source:"manual"})))
      .concat((pmBookings||[]).map(b => ({...b, source:"perfectmind"})));

  const target = normalizeDate(dateStr);

    let filtered = all
      .filter(b => normalizeDate(b.date) === target)
      .filter(b => b.venue);

    // Dashboard-only condense pass:
    filtered = condenseSwimmingPoolDashboardOnly(filtered);

  return filtered;

  }

  /**
 * Group bookings that are the “same booking” but repeated for different areas.
 * Key = venue + start + end + name (+ source if you want to keep manual/PM separate)
 */
  function condenseBookings(list){
    const map = new Map();

    list.forEach(b => {
      const key = [
        normKey(b.venue),
        normKey(b.start),
        normKey(b.end),
        normKey(b.name),
      ].join("|");

      if (!map.has(key)){
        map.set(key, {
          ...b,
          areas: [],
          notesList: []
        });
      }

      const g = map.get(key);
      if (b.area) g.areas.push(b.area);
      if (b.notes) g.notesList.push(b.notes);

      // keep rowNumbers for manual deletes if needed later
      if (b.source === "manual" && b.rowNumber){
        g.rowNumbers = g.rowNumbers || [];
        g.rowNumbers.push(b.rowNumber);
      }
    });

    // Finalize
    return Array.from(map.values()).map(g => {
      const areas = uniq(g.areas);
      const notes = uniq(g.notesList).join(" • ");

      return {
        ...g,
        areaCombined: areas.join(", "),
        areasCount: areas.length,
        notesCombined: notes
      };
    });
  }

  function render(){
    const dateStr = getSelectedDate();
    const allRaw = mergedForDate(dateStr);
    const all = condenseBookings(allRaw);


    // group by venue
    const byVenue = {};
    VENUES.forEach(v => byVenue[v] = []);
    all.forEach(b => {
      const v = b.venue;
      if (!byVenue[v]) byVenue[v] = [];
      byVenue[v].push(b);
    });

    Object.keys(byVenue).forEach(v => {
      byVenue[v].sort((a,b) => toMin(a.start) - toMin(b.start) || toMin(a.end) - toMin(b.end));
    });

    // info line
    const info = document.getElementById("sourceInfo");
    const manualCount = all.filter(x => x.source === "manual").length;
    const pmCount = all.filter(x => x.source === "perfectmind").length;
    info.textContent = `Showing ${all.length} bookings • Manual ${manualCount} • PerfectMind ${pmCount}` +
      (lastPerfectMindFile ? ` • Latest CSV: ${lastPerfectMindFile}` : "");

    // render venue cards (hide empty) + sort by busyness
    const wrap = document.getElementById("venueWrap");
    wrap.innerHTML = "";

    const venuesWithBookings = VENUES
      .map(v => {
      const items = byVenue[v] || [];
      return { venue: v, items, score: venueBusynessScore(items) };
     })
     .filter(x => x.items.length > 0)
     .sort((a, b) => b.score - a.score);

    venuesWithBookings.forEach(({ venue, items }) => {
      wrap.innerHTML += renderVenueCard(venue, items);
    });

    // If literally nothing is booked, show a friendly message (instead of blank grid)
    if (!venuesWithBookings.length){
      wrap.innerHTML = `
        <div class="bg-card border border-line rounded-2xl p-4 text-sm font-black text-muted">
        No bookings today in this location.
        </div>
      `;
    }

    // Fit grid to screen (avoid scrollbars)
    fitToScreen();



  }

  function renderVenueCard(venue, items, isEmpty = false){
    return `
      <div class="venueCard bg-card border border-line rounded-2xl p-3 flex flex-col
                  ${isEmpty ? "opacity-60 order-last" : ""}">
        <div class="flex items-center justify-between gap-2">
          <div class="font-black text-base">${escapeHtml(venue)}</div>
          <div class="text-xs font-extrabold text-muted">
            ${items.length} booking(s)
          </div>
        </div>

        <div class="mt-2 space-y-2 pr-1 flex-1 bookingList">
          ${
            items.length
              ? items.map(renderBookingRow).join("")
              : `<div class="text-xs font-extrabold text-muted italic">No bookings</div>`
          }
        </div>
      </div>
    `;
  }
  
  function fitToScreen(){
    const stage = document.getElementById("venueStage");
    const wrap  = document.getElementById("venueWrap");
    if (!stage || !wrap) return;

    // Always measure at scale=1, then apply a scale that fits the whole grid.
    wrap.style.setProperty("--dashScale", "1");

    const isMobile = window.matchMedia("(max-width: 900px)").matches;
    if (isMobile){
      // Mobile: readability > fit-to-screen. Allow page scroll.
      document.body.style.overflow = "auto";
      return;
    }

    // Desktop: input-free display mode (no page scroll; scale grid to fit).
    document.body.style.overflow = "hidden";

    const header = document.querySelector("header");
    const headerH = header ? header.offsetHeight : 86;
    stage.style.height = `calc(100vh - ${headerH}px)`;

    // Force reflow after height update
    const availW = stage.clientWidth || window.innerWidth;
    const availH = stage.clientHeight || (window.innerHeight - headerH);

    const neededW = wrap.scrollWidth;
    const neededH = wrap.scrollHeight;

    const scaleW = availW > 0 ? (availW / neededW) : 1;
    const scaleH = availH > 0 ? (availH / neededH) : 1;

    // Never scale up, only down. Keep a readability floor.
    const floor = 0.58;
    const scale = Math.max(floor, Math.min(1, scaleW, scaleH));

    wrap.style.setProperty("--dashScale", String(scale.toFixed(3)));
  }

  window.addEventListener("resize", () => {
    window.requestAnimationFrame(() => fitToScreen());
  });

  });


  function parseHM(t){
    const m = /^(\d{1,2}):(\d{2})$/.exec(String(t||"").trim());
    if (!m) return null;
    return { h: parseInt(m[1],10), m: parseInt(m[2],10) };
  }

  function durationMins(start, end){
    const s = parseHM(start), e = parseHM(end);
    if (!s || !e) return 0;
    return Math.max(0, (e.h*60 + e.m) - (s.h*60 + s.m));
  }

/**
 * Higher score = show earlier in grid.
 * Weight both count + total minutes so a venue with fewer long bookings
 * doesn't get buried under lots of short ones.
 */
  function venueBusynessScore(items){
  const count = items.length;
  const mins = items.reduce((sum, b) => sum + durationMins(b.start, b.end), 0);
  return (count * 10000) + mins; // count dominates, minutes breaks ties
  }

  

function renderBookingRow(b){
  const srcPill = (b.source === "manual")
    ? `<span class="rounded-full px-2.5 py-1 text-[11px] font-black bg-pindan text-white">Manual</span>`
    : ``;

  const deleteBtn = (b.source === "manual" && b.rowNumber)
    ? `<button class="rounded-xl px-3 py-2 font-black text-white bg-bad"
          type="button" onclick="deleteManual(${b.rowNumber})">Delete</button>`
    : "";

  const area = (b.area || "").trim();
  const notes = (b.notes || "").trim();
  const activity = (b.activity || "").trim();

  const showActivity =
    activity &&
    String(b.venue || "").toLowerCase().includes("multipurpose");

  return `
    <div class="bookingRow border border-line rounded-2xl bg-[#06181f] p-3">
      <div class="flex items-start justify-between gap-3">
        <div class="min-w-0">
          <div class="title font-black">
            ${escapeHtml(b.start)}–${escapeHtml(b.end)} • ${escapeHtml(b.name || "Booking")}
          </div>

          <div class="meta font-extrabold text-muted mt-1 leading-snug">
            ${area ? `Area: ${escapeHtml(area)}` : `&nbsp;`}
            ${showActivity ? `<div class="mt-1">Activity: ${escapeHtml(activity)}</div>` : ""}
            ${notes ? `<div class="mt-1">Notes: ${escapeHtml(notes)}</div>` : ""}
          </div>
        </div>

        <div class="flex flex-col items-end gap-2 shrink-0">
          ${srcPill}
          ${deleteBtn}
        </div>
      </div>
    </div>
  `;
}

  async function loadAll(showToast){
    try{
      if (showToast) toast("Loading…", 1200);

      // load both sources in parallel
      await Promise.all([loadManual(), loadPerfectMind()]);
      render();

      if (showToast) toast("Loaded ✅", 1200);
    } catch(e){
      console.error(e);
      toast("Load failed (check script / folder ID)", 3500);
      // still try rendering what we have
      render();
    }
  }

  // ====== BOOT ======
  (function boot(){
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    document.getElementById("datePick").value = `${yyyy}-${mm}-${dd}`;

    loadAll(true);
  })();
</script>
</body>
</html>
